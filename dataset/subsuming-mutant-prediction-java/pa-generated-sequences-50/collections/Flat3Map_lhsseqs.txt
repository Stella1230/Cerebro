} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR5Mutator]MSP[] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR3Mutator]MSP[] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR6Mutator]MSP[] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR1Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override MST[experimental.MemberVariableMutator]MSP[] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NonVoidMethodCallMutator]MSP[] }
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[NegateConditionalsMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ; MST[NonVoidMethodCallMutator]MSP[]
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR3Mutator]MSP[] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.UOI1Mutator]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR1Mutator]MSP[]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[InlineConstantMutator]MSP[] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR5Mutator]MSP[]
} @Override public void remove () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR5Mutator]MSP[] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; MST[ConstructorCallMutator]MSP[] } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR1Mutator]MSP[] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[ReturnValsMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR3Mutator]MSP[] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; MST[ReturnValsMutator]MSP[] case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR3Mutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR2Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR3Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public void remove () { if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI3Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI2Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR1Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[InlineConstantMutator]MSP[] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR4Mutator]MSP[] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.UOI4Mutator]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[NonVoidMethodCallMutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOD1Mutator]MSP[] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[experimental.MemberVariableMutator]MSP[] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI4Mutator]MSP[] return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR5Mutator]MSP[] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR3Mutator]MSP[]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; MST[ReturnValsMutator]MSP[] case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR1Mutator]MSP[] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[InlineConstantMutator]MSP[] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI1Mutator]MSP[] return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.ABSMutator]MSP[] return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR6Mutator]MSP[] nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR3Mutator]MSP[] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR1Mutator]MSP[] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR4Mutator]MSP[] nextIndex ++ ; return getKey () ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; MST[ReturnValsMutator]MSP[] } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; }
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR5Mutator]MSP[] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR2Mutator]MSP[] nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; MST[NullReturnValsMutator]MSP[] case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[InlineConstantMutator]MSP[] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR4Mutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR2Mutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; MST[ConstructorCallMutator]MSP[] } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ; MST[ReturnValsMutator]MSP[]
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[experimental.MemberVariableMutator]MSP[] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; MST[NonVoidMethodCallMutator]MSP[] case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR6Mutator]MSP[] return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[experimental.MemberVariableMutator]MSP[] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR2Mutator]MSP[] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR4Mutator]MSP[]
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; MST[NullReturnValsMutator]MSP[] case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[MathMutator]MSP[] return getKey () ;
if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override MST[rv.CRCR1Mutator]MSP[] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI3Mutator]MSP[] return getKey () ;
} @Override MST[rv.CRCR5Mutator]MSP[] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[ConditionalsBoundaryMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR4Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[experimental.MemberVariableMutator]MSP[] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI4Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI1Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.ABSMutator]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR2Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR5Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[NegateConditionalsMutator]MSP[]
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR2Mutator]MSP[] return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[ReturnValsMutator]MSP[] }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI2Mutator]MSP[] return getKey () ;
} @Override MST[rv.CRCR6Mutator]MSP[] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR3Mutator]MSP[] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ABSMutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR4Mutator]MSP[] return getKey () ;
if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR2Mutator]MSP[]
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.SwitchMutator]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.UOI3Mutator]MSP[] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public void remove () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public void remove () { if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR6Mutator]MSP[] } @Override public String toString () { if ( canRemove ) {
if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NullReturnValsMutator]MSP[] }
} @Override MST[rv.CRCR3Mutator]MSP[] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR4Mutator]MSP[] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR1Mutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ; MST[NullReturnValsMutator]MSP[]
} @Override MST[InlineConstantMutator]MSP[] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; MST[NonVoidMethodCallMutator]MSP[] case 1 : return parent . key1 ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI1Mutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; MST[ConstructorCallMutator]MSP[] }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; MST[ReturnValsMutator]MSP[] }
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI3Mutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI2Mutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[]
final boolean result = parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; MST[NullReturnValsMutator]MSP[] }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new EntrySetIterator <> ( parent ) ; }
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[NonVoidMethodCallMutator]MSP[]
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[]
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.ABSMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[ReturnValsMutator]MSP[] } return new EntrySetIterator <> ( parent ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[]
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[NullReturnValsMutator]MSP[] } return new EntrySetIterator <> ( parent ) ; }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI4Mutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public boolean remove ( final Object obj ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
} else { if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; MST[NullReturnValsMutator]MSP[] } } } else { if ( size > 0 ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[]
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR5Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ; MST[ReturnValsMutator]MSP[]
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[experimental.MemberVariableMutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
value2 = null ; size = 1 ; MST[rv.CRCR4Mutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[] } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; MST[experimental.NakedReceiverMutator]MSP[] if ( cloned . delegateMap != null ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value3 ; value3 = value ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
hash3 = 0 ; MST[InlineConstantMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] return value3 ; } case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; MST[ReturnValsMutator]MSP[] } case 2 :
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
} else { if ( size > 0 ) { MST[rv.ABSMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; MST[ReturnValsMutator]MSP[] } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[ReturnValsMutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[MathMutator]MSP[] case 2 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR6Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; MST[NullReturnValsMutator]MSP[] } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR1Mutator]MSP[] hash1 = hash2 = hash3 = 0 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; return null ; MST[ReturnValsMutator]MSP[] } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI4Mutator]MSP[] key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] case 0 : break; default:
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.ABSMutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; MST[ReturnValsMutator]MSP[] } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
if ( value1 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR1Mutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; MST[ReturnValsMutator]MSP[] } } } } return null ; } @Override
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[InlineConstantMutator]MSP[] } case 2 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
return; } if ( size < 4 ) { MST[rv.ROR2Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new FlatMapIterator <> ( this ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; MST[EmptyObjectReturnValsMutator]MSP[] }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] final V old = value3 ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR3Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } }
if ( size != other . size () ) { MST[rv.UOI3Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; MST[NonVoidMethodCallMutator]MSP[] case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
} else { if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[]
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[]
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[rv.ROR5Mutator]MSP[] buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] return value3 ; } case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[InlineConstantMutator]MSP[] key2 = key ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( size != other . size () ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value3 ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value3 ; value3 = value ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[]
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR1Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . containsValue ( value ) ;
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } else {
return null ; MST[ReturnValsMutator]MSP[] case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; MST[ReturnValsMutator]MSP[] } @Override public V remove ( final Object key ) {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[ConstructorCallMutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] return value1 ; } } } } return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[]
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] final V old = value1 ; hash1 = hash2 ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; MST[ConstructorCallMutator]MSP[] } @Override public V remove ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI1Mutator]MSP[] key2 = key3 ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[NullReturnValsMutator]MSP[] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR2Mutator]MSP[]
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR5Mutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.ROR5Mutator]MSP[] case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR5Mutator]MSP[] } @Override public int hashCode () {
return; } if ( size < 4 ) { MST[rv.ROR5Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[InlineConstantMutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[InlineConstantMutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI1Mutator]MSP[] return null ; } @Override
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[InlineConstantMutator]MSP[] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
return; } if ( size < 4 ) { MST[rv.ABSMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR5Mutator]MSP[] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] case 0 : break; default:
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[NegateConditionalsMutator]MSP[] case 0 : break; default:
if ( value1 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V old = value3 ; value3 = value ;
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR1Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR3Mutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[]
if ( size > 0 ) { final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . containsValue ( value ) ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return true ; MST[InlineConstantMutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[] case 2 :
final V old = value3 ; hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value3 ; value3 = value ; return old ; } case 2 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[] return lr_8 ; }
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
value2 = null ; size = 1 ; MST[InlineConstantMutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[]
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[ReturnValsMutator]MSP[] } @Override public int hashCode () {
value2 = value3 ; hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[ReturnValsMutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.ABSMutator]MSP[] case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[InlineConstantMutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[experimental.MemberVariableMutator]MSP[] key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.ABSMutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] return value3 ; } case 2 :
return new EntrySet <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
return; } if ( size < 4 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
} if ( value == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; hash2 = 0 ; key2 = null ;
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR2Mutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] return value1 ; } } } } return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR4Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR6Mutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
public Set < K > keySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( size != other . size () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR6Mutator]MSP[] return null ; } @Override
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
value2 = value3 ; hash3 = 0 ; MST[InlineConstantMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; MST[PrimitiveReturnsMutator]MSP[] } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( value1 == null ) { MST[NegateConditionalsMutator]MSP[] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR1Mutator]MSP[] return old ; } }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[]
final V old = value3 ; hash3 = 0 ; MST[InlineConstantMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOD1Mutator]MSP[] return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[MathMutator]MSP[] case 0 : break; default:
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[] } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[NonVoidMethodCallMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
if ( key2 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[InlineConstantMutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] return value1 ; } } } } return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[InlineConstantMutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR3Mutator]MSP[] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR1Mutator]MSP[] key2 = key ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI4Mutator]MSP[] key1 = key3 ; value1 = value3 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
public Collection < V > values () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[]
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[]
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR4Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value3 ; value3 = value ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[]
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } }
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[]
if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR6Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] return value3 ; } case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] key2 = key ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; MST[NullReturnValsMutator]MSP[] } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value3 ; value3 = value ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value1 ; } } } else { if ( size > 0 ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
return; } if ( size < 4 ) { MST[rv.UOI2Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[] } case 2 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR4Mutator]MSP[] return buf . toString () ; }
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return true ; MST[BooleanFalseReturnValsMutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI3Mutator]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.ABSMutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value3 ;
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] final V old = value1 ; hash1 = hash2 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
value2 = value ; MST[experimental.MemberVariableMutator]MSP[] break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR3Mutator]MSP[] return null ; } @Override
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ABSMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
return true ; MST[rv.CRCR4Mutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[rv.ROR5Mutator]MSP[] buf . append ( '=' ) ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[MathMutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[ReturnValsMutator]MSP[] } }
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[] return value1 ; } } } else { if ( size > 0 ) {
} if ( value == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] case 0 : break; default:
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } case 1 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; hash1 = hash2 ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] delegateMap . putAll ( map ) ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; MST[NonVoidMethodCallMutator]MSP[] case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[NegateConditionalsMutator]MSP[] buf . append ( '=' ) ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR5Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[NegateConditionalsMutator]MSP[] buf . append ( '=' ) ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR1Mutator]MSP[] return buf . toString () ; }
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[] } } @Override
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[] return lr_8 ; }
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.ABSMutator]MSP[] case 0 : break; default:
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } case 1 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[] return true ; } case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value3 ; value3 = value ;
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[] return true ; } case 2 :
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[]
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[InlineConstantMutator]MSP[] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[rv.ROR5Mutator]MSP[] buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] return value3 ; } case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI4Mutator]MSP[] return null ; } @Override
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR2Mutator]MSP[]
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; MST[ReturnValsMutator]MSP[] }
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 = value3 = null ; } } @Override
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[]
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[ReturnValsMutator]MSP[] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[]
} else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( '=' ) ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR4Mutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
public int size () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[] return value1 ; } } } else { if ( size > 0 ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[NegateConditionalsMutator]MSP[] buf . append ( '=' ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value3 ; value3 = value ; return old ; } case 2 :
if ( size != other . size () ) { return false ; MST[ReturnValsMutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[ReturnValsMutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[] case 0 : break; default:
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] return value3 ; } case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; hash2 = 0 ; key2 = null ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; MST[NonVoidMethodCallMutator]MSP[] if ( size == 0 ) { return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; MST[ReturnValsMutator]MSP[] }
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value3 ; value3 = value ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[]
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; hash1 = hash2 ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR6Mutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( value1 == null ) { MST[rv.ROR5Mutator]MSP[] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[]
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI2Mutator]MSP[] key1 = key3 ; value1 = value3 ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI1Mutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( '=' ) ;
if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[InlineConstantMutator]MSP[] hash1 = hash2 = hash3 = 0 ;
} if ( value == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
value2 = null ; size = 1 ; return old ; MST[ReturnValsMutator]MSP[] } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
final V old = value2 ; hash2 = 0 ; MST[InlineConstantMutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
value2 = value3 ; hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[]
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value3 ; value3 = value ;
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[ReturnValsMutator]MSP[] } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] case 2 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
final V old = value3 ; hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR6Mutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[NonVoidMethodCallMutator]MSP[] return buf . toString () ; }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] return value3 ; } case 2 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI4Mutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[]
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public int hashCode () {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR6Mutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[]
if ( size != other . size () ) { MST[rv.UOI4Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return; } if ( size < 4 ) { MST[rv.UOI4Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; hash1 = hash2 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[]
hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] return value1 ; } } } } return null ; } @Override
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( value1 == null ) { return true ; MST[InlineConstantMutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR5Mutator]MSP[] hash1 = hash2 = hash3 = 0 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[ReturnValsMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] final V old = value3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value3 ;
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR6Mutator]MSP[] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] return value1 ; } } } } return null ; } @Override
return value3 ; } case 2 : if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value3 ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } case 1 :
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.ABSMutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return; } if ( size < 4 ) { MST[rv.CRCR1Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[InlineConstantMutator]MSP[] return old ; } }
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] return value3 ; } case 2 :
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[] } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; MST[VoidMethodCallMutator]MSP[] delegateMap . put ( key , value ) ;
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR4Mutator]MSP[] } @Override public int hashCode () {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] switch ( size ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[] case 2 :
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( key3 == null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[NonVoidMethodCallMutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR3Mutator]MSP[] key2 = key ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] return value3 ; } case 2 :
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; MST[experimental.MemberVariableMutator]MSP[] value1 = value ; break; } size ++ ; return null ; } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] return value1 ; } } } } return null ; } @Override
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } case 1 :
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR5Mutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[NegateConditionalsMutator]MSP[] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[]
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[NegateConditionalsMutator]MSP[] return true ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value3 ; value3 = value ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value3 ; value3 = value ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[InlineConstantMutator]MSP[] case 0 : break; default:
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI3Mutator]MSP[] key2 = key3 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR6Mutator]MSP[] key2 = key ;
hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR3Mutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
} else { if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR1Mutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR4Mutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
return; } if ( size < 4 ) { MST[rv.CRCR4Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
delegateMap . put ( key2 , value2 ) ; MST[ArgumentPropagationMutator]MSP[] case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value3 ; value3 = value ;
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[rv.ROR5Mutator]MSP[] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[]
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[]
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[rv.ROR5Mutator]MSP[] return true ; } case 1 :
return value3 ; } case 2 : if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value3 ; value3 = value ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] delegateMap . putAll ( map ) ;
return; } if ( size < 4 ) { MST[rv.ROR1Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[ReturnValsMutator]MSP[]
final V old = value1 ; hash1 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[NegateConditionalsMutator]MSP[] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[NegateConditionalsMutator]MSP[] return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; MST[experimental.MemberVariableMutator]MSP[] break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR5Mutator]MSP[]
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] case 0 : break; default:
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR3Mutator]MSP[] key2 = null ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] return value3 ; } case 2 :
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[]
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( key2 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR3Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = null ; size = 0 ; return old ; } }
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; value1 = value ; return old ; } } } else {
if ( key2 == null ) { return true ; MST[ReturnValsMutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR3Mutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key2 = null ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[rv.ROR5Mutator]MSP[] return true ;
if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR1Mutator]MSP[] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] return value3 ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI2Mutator]MSP[] key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] return value3 ; } case 2 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
} if ( value == null ) { MST[rv.ROR5Mutator]MSP[] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR5Mutator]MSP[] return old ; } }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} else { if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[NegateConditionalsMutator]MSP[]
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR2Mutator]MSP[] return null ; } @Override
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value3 ; value3 = value ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; MST[InlineConstantMutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[ReturnValsMutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
key1 = key2 ; value1 = value2 ; MST[experimental.MemberVariableMutator]MSP[] hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR6Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[]
} else { if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[experimental.MemberVariableMutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[]
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI4Mutator]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } case 1 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } case 1 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; key1 = key3 ; MST[experimental.MemberVariableMutator]MSP[] value1 = value3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.ABSMutator]MSP[] case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.ABSMutator]MSP[] return null ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( size != other . size () ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value3 ;
if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[PrimitiveReturnsMutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( key3 == null ) {
if ( size != other . size () ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
public Collection < V > values () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR3Mutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( value1 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR5Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[] case 0 : break; default:
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[NullReturnValsMutator]MSP[] } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; MST[experimental.MemberVariableMutator]MSP[] return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[NegateConditionalsMutator]MSP[] key2 = key ;
if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR3Mutator]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[] } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
return; } if ( size < 4 ) { MST[InlineConstantMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
} if ( value == null ) { MST[NegateConditionalsMutator]MSP[] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( key3 == null ) {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] case 0 : break; default:
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; MST[ReturnValsMutator]MSP[] } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; MST[experimental.MemberVariableMutator]MSP[] value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 = value3 = null ; } } @Override
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
return new EntrySet <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
return; } if ( size < 4 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( value1 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[] }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] return value3 ; } case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] return value3 ; } case 2 :
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( key3 == null ) {
hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
return; } if ( size < 4 ) { MST[NegateConditionalsMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR3Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR1Mutator]MSP[] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] return value1 ; } } } } return null ; } @Override
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR5Mutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[InlineConstantMutator]MSP[]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; MST[NonVoidMethodCallMutator]MSP[] switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value1 ; } } } else { if ( size > 0 ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR3Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[] return lr_8 ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; MST[NullReturnValsMutator]MSP[] } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI3Mutator]MSP[] key1 = key3 ; value1 = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; MST[NullReturnValsMutator]MSP[] } } } } return null ; } @Override
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . entrySet () ; }
} else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value3 ; value3 = value ;
return; } if ( size < 4 ) { MST[rv.UOI1Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[]
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[InlineConstantMutator]MSP[] case 2 :
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR5Mutator]MSP[] return null ; } @Override
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value3 ; value3 = value ;
if ( size != other . size () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; MST[NullReturnValsMutator]MSP[] } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOD2Mutator]MSP[] return null ; } @Override
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
} else { if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( value1 == null ) { return true ; MST[ReturnValsMutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR3Mutator]MSP[] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; MST[ReturnValsMutator]MSP[] } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[InlineConstantMutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_8 ; }
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.ROR5Mutator]MSP[] key2 = key ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR6Mutator]MSP[] key2 = null ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] return value1 ; } } } } return null ; } @Override
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[experimental.MemberVariableMutator]MSP[] hash1 = hash2 = hash3 = 0 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] return value1 ; } } } } return null ; } @Override
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
return true ; MST[rv.CRCR5Mutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] return value3 ; } case 2 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR5Mutator]MSP[]
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
public Collection < V > values () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; MST[NullReturnValsMutator]MSP[] } case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; MST[experimental.MemberVariableMutator]MSP[] switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[InlineConstantMutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
} if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 0 ; return old ; } }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] case 0 : break; default:
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR4Mutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR4Mutator]MSP[] return null ; } @Override
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[InlineConstantMutator]MSP[] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ; MST[experimental.MemberVariableMutator]MSP[]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[experimental.NakedReceiverMutator]MSP[] return buf . toString () ; }
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR3Mutator]MSP[] return old ; } }
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[NonVoidMethodCallMutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( value1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR1Mutator]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR6Mutator]MSP[] return buf . toString () ; }
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[NullReturnValsMutator]MSP[] } }
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR2Mutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ; MST[experimental.MemberVariableMutator]MSP[]
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value3 ; value3 = value ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] return value3 ; } case 2 :
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value3 ; value3 = value ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR6Mutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI4Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( size != other . size () ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI1Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR4Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR5Mutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( size != other . size () ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] return value1 ; } } } } return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[] case 0 : break; default:
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[NullReturnValsMutator]MSP[] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[ReturnValsMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[]
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[NonVoidMethodCallMutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] case 0 : break; default:
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[]
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[] } } @Override
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
} else { if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR5Mutator]MSP[] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[]
if ( key2 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; MST[ReturnValsMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( '=' ) ;
} if ( value == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[experimental.MemberVariableMutator]MSP[]
hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR6Mutator]MSP[] return old ; } }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] case 2 :
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] delegateMap . putAll ( map ) ;
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ABSMutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] return value1 ; } } } } return null ; } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR1Mutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR6Mutator]MSP[] hash1 = hash2 = hash3 = 0 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } case 1 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . containsValue ( value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[]
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.ABSMutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[]
public int size () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[]
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[InlineConstantMutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[experimental.NakedReceiverMutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[] }
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] case 0 : break; default:
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] case 2 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[experimental.MemberVariableMutator]MSP[] key2 = key ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value3 ; } case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[ReturnValsMutator]MSP[] } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI3Mutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
return true ; MST[rv.CRCR2Mutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] return value3 ; } case 2 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] case 2 :
if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value3 ; value3 = value ; return old ; } case 2 :
delegateMap . put ( key2 , value2 ) ; MST[NonVoidMethodCallMutator]MSP[] case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[InlineConstantMutator]MSP[] return null ; } @Override
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI2Mutator]MSP[] return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ABSMutator]MSP[]
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[] } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[InlineConstantMutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] key2 = key ;
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR6Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[experimental.MemberVariableMutator]MSP[] return null ; } @Override
return; } if ( size < 4 ) { MST[rv.CRCR5Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( key3 == null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR2Mutator]MSP[] return null ; } @Override
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[InlineConstantMutator]MSP[]
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] return value3 ; } case 2 :
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; MST[NonVoidMethodCallMutator]MSP[] } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
return; } if ( size < 4 ) { MST[rv.UOI3Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR2Mutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[] } case 2 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR3Mutator]MSP[] return buf . toString () ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] return value1 ; } } } } return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[] case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { if ( delegateMap != null ) {
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; MST[NullReturnValsMutator]MSP[] } @Override public V remove ( final Object key ) {
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return value3 ; MST[ReturnValsMutator]MSP[] } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value1 ; hash1 = 0 ; MST[InlineConstantMutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( key3 == null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 = value3 = null ; } } @Override
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[]
if ( size != other . size () ) { MST[rv.ABSMutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
value2 = null ; size = 1 ; MST[rv.CRCR2Mutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR3Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[InlineConstantMutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[ReturnValsMutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR6Mutator]MSP[] } @Override public int hashCode () {
} else { if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value3 ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] return value3 ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; MST[ReturnValsMutator]MSP[] case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
} if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[]
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR1Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } }
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; MST[experimental.MemberVariableMutator]MSP[] return old ; } } } else {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[rv.ROR5Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( '=' ) ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[] case 0 : break; default:
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( key3 == null ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( key3 == null ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[]
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( key3 == null ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[]
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[NegateConditionalsMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] case 0 : break; default:
hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[InlineConstantMutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
public int size () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( size != other . size () ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.SwitchMutator]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
return; } if ( size < 4 ) { MST[rv.ROR4Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.ABSMutator]MSP[] key2 = key3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR4Mutator]MSP[]
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[experimental.NakedReceiverMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . entrySet () ; }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[]
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[] return lr_8 ; }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR1Mutator]MSP[]
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[rv.ROR5Mutator]MSP[] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] return true ; } case 1 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[NullReturnValsMutator]MSP[] } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR4Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( '=' ) ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[ReturnValsMutator]MSP[] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . containsValue ( value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[]
} else { if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
} else { if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR6Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR5Mutator]MSP[] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] case 2 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR1Mutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public boolean containsKey ( final Object key ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[]
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } case 1 :
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value1 ; } } } } return null ; } @Override
} if ( value == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
value2 = null ; size = 1 ; MST[rv.CRCR5Mutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] final V old = value3 ; value3 = value ;
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
} if ( value == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value3 ;
} if ( value == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
value2 = null ; size = 1 ; return old ; MST[NullReturnValsMutator]MSP[] } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value3 ; value3 = value ; return old ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR4Mutator]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR5Mutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } }
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[] return lr_8 ; }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value3 ; } case 2 :
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; MST[NullReturnValsMutator]MSP[] } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[] } case 2 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[]
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[NullReturnValsMutator]MSP[] } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; MST[ReturnValsMutator]MSP[] } } } else { if ( size > 0 ) {
if ( size != other . size () ) { MST[rv.UOI1Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI1Mutator]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } case 1 :
value2 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 1 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
return true ; MST[rv.CRCR6Mutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[experimental.MemberVariableMutator]MSP[] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( size > 0 ) { MST[rv.ABSMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : if ( key3 == null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] case 0 : break; default:
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return value3 ; } case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[] } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR2Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] case 2 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value1 ; } } } } return null ; } @Override
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( value1 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
convertToMap () ; MST[VoidMethodCallMutator]MSP[] delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; MST[ArgumentPropagationMutator]MSP[] case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; MST[experimental.MemberVariableMutator]MSP[] value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value3 ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : if ( key3 == null ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[]
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ABSMutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
} else { if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[ReturnValsMutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR3Mutator]MSP[] } @Override public int hashCode () {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.ABSMutator]MSP[] case 0 : break; default:
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; MST[experimental.MemberVariableMutator]MSP[] break; } size ++ ; return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
return true ; MST[ReturnValsMutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; value1 = value ; return old ; } } } else {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value3 ; value3 = value ;
return; } if ( size < 4 ) { MST[rv.CRCR2Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[] return lr_8 ; }
if ( size != other . size () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else {
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[InlineConstantMutator]MSP[] } @Override public int hashCode () {
final V old = value2 ; hash2 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR5Mutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR3Mutator]MSP[] hash1 = hash2 = hash3 = 0 ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( key3 == null ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR2Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value3 ; } case 2 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[]
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
public Set < K > keySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[] return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR1Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[MathMutator]MSP[] case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[experimental.NakedReceiverMutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; MST[ArgumentPropagationMutator]MSP[] case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value3 ;
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[]
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ; MST[experimental.MemberVariableMutator]MSP[]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR6Mutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR5Mutator]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR3Mutator]MSP[]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[] return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR2Mutator]MSP[] return buf . toString () ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; MST[NullReturnValsMutator]MSP[] } } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[]
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.ABSMutator]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR2Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[] return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR1Mutator]MSP[] return null ; } @Override
key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[]
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[ReturnValsMutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( size != other . size () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI3Mutator]MSP[] return null ; } @Override
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.ROR5Mutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ; MST[experimental.MemberVariableMutator]MSP[]
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR5Mutator]MSP[] key2 = null ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.ABSMutator]MSP[] key1 = key3 ; value1 = value3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] case 2 :
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; MST[ReturnValsMutator]MSP[] } } } else {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[PrimitiveReturnsMutator]MSP[] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[experimental.NakedReceiverMutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] return value3 ; } case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR1Mutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value3 ; value3 = value ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[] return value1 ; } } } } return null ; } @Override
} if ( value == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[InlineConstantMutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } }
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public Collection < V > values () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[] } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR5Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
value2 = null ; size = 1 ; MST[rv.CRCR3Mutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR3Mutator]MSP[] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] case 0 : break; default:
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[InlineConstantMutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR3Mutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
convertToMap () ; delegateMap . putAll ( map ) ; MST[VoidMethodCallMutator]MSP[] } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
} if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR5Mutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( key3 == null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[InlineConstantMutator]MSP[] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( '=' ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[] return value3 ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( size != other . size () ) { return false ; MST[InlineConstantMutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR2Mutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[MathMutator]MSP[] return null ; } @Override
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI3Mutator]MSP[]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI2Mutator]MSP[]
if ( size != other . size () ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( value1 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value3 ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_8 ; }
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR6Mutator]MSP[] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
return true ; MST[rv.CRCR3Mutator]MSP[] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
return value3 ; MST[NullReturnValsMutator]MSP[] } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[]
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR2Mutator]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[NegateConditionalsMutator]MSP[] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[InlineConstantMutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; MST[ReturnValsMutator]MSP[] } @Override
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR3Mutator]MSP[] return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[InlineConstantMutator]MSP[] return buf . toString () ; }
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value3 ; value3 = value ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[]
hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[ReturnValsMutator]MSP[]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[]
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
return value3 ; } case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[InlineConstantMutator]MSP[] key2 = null ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.ROR5Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; hash2 = 0 ; key2 = null ;
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR6Mutator]MSP[] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[ReturnValsMutator]MSP[] } return new FlatMapIterator <> ( this ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR6Mutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value3 ; value3 = value ;
return new EntrySet <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[] } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; MST[experimental.MemberVariableMutator]MSP[] value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[]
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( key3 == null ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR4Mutator]MSP[] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[]
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI2Mutator]MSP[] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( key2 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[] } case 2 :
if ( value1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR2Mutator]MSP[] } @Override public int hashCode () {
return; } if ( size < 4 ) { MST[ConditionalsBoundaryMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
value2 = null ; size = 1 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[] case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( key3 == null ) { return true ; } case 2 :
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; MST[ReturnValsMutator]MSP[] } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[]
value2 = null ; size = 1 ; MST[rv.CRCR6Mutator]MSP[] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[experimental.MemberVariableMutator]MSP[] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR5Mutator]MSP[] key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR5Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[]
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR1Mutator]MSP[] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] case 0 : break; default:
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[NullReturnValsMutator]MSP[] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[]
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR6Mutator]MSP[]
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
value2 = value3 ; MST[experimental.MemberVariableMutator]MSP[] hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[]
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return; } if ( size < 4 ) { MST[rv.CRCR3Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.ROR5Mutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[NegateConditionalsMutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
} if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return value1 ; } } } } return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[] return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[]
} if ( value == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[]
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } case 1 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR4Mutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[NegateConditionalsMutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
return; } if ( size < 4 ) { MST[rv.CRCR6Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR2Mutator]MSP[] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[] return lr_8 ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; MST[experimental.MemberVariableMutator]MSP[] size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V old = value3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[MathMutator]MSP[] case 0 : break; default:
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[] } } @Override
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] return value1 ; } } } } return null ; } @Override
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[] return true ; } case 1 :
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR3Mutator]MSP[] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] return value1 ; } } } } return null ; } @Override
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[] } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.ROR5Mutator]MSP[] case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[] return lr_8 ; }
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI1Mutator]MSP[] key1 = key3 ; value1 = value3 ;
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . entrySet () ; }
final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[] } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[ReturnValsMutator]MSP[] } case 2 :
if ( key2 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] delegateMap . putAll ( map ) ;
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR1Mutator]MSP[] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( size != other . size () ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; MST[ReturnValsMutator]MSP[] } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value2 ; value2 = value ; return old ; } case 1 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR5Mutator]MSP[] return buf . toString () ; }
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR1Mutator]MSP[] key2 = null ;
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[] final V old = value1 ; value1 = value ; return old ; } } } else {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR1Mutator]MSP[] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[] switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NonVoidMethodCallMutator]MSP[] return value3 ; } case 2 :
if ( key2 == null ) { final V old = value2 ; value2 = value ; MST[experimental.MemberVariableMutator]MSP[] return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
} if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[NegateConditionalsMutator]MSP[] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] key2 = key ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[] return value3 ; } case 2 :
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return delegateMap . entrySet () ; }
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) {
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR3Mutator]MSP[]
key1 = key2 ; MST[experimental.MemberVariableMutator]MSP[] value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean containsKey ( final Object key ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[] final V old = value3 ; value3 = value ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( size != other . size () ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[NegateConditionalsMutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR5Mutator]MSP[] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[]
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR3Mutator]MSP[] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR4Mutator]MSP[] return null ; } @Override
hash3 = 0 ; MST[InlineConstantMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[] case 0 : break; default:
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[] return lr_8 ; }
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[]
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[] if ( cloned . delegateMap != null ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR3Mutator]MSP[] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( size != other . size () ) { MST[rv.UOI2Mutator]MSP[] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[]
if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[MathMutator]MSP[] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[]
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[InlineConstantMutator]MSP[] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI2Mutator]MSP[] default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( size != other . size () ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] put ( entry . getKey () , entry . getValue () ) ; } } else {
} if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI4Mutator]MSP[] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
return; } if ( size < 4 ) { MST[rv.ROR3Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[experimental.MemberVariableMutator]MSP[] key1 = key3 ; value1 = value3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[NegateConditionalsMutator]MSP[] case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[] final V old = value3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[] case 3 : if ( key3 == null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V old = value3 ; value3 = value ;
if ( parent . size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
if ( parent . size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
if ( parent . size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
if ( parent . size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[NonVoidMethodCallMutator]MSP[] return parent . delegateMap . keySet () . iterator () ; }
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
if ( parent . size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
if ( parent . size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public void clear () {
parent . remove ( key ) ; return result ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () {
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; return result ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; MST[ReturnValsMutator]MSP[] } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
parent . remove ( key ) ; return result ; MST[rv.ABSMutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; MST[NullReturnValsMutator]MSP[] } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; MST[ReturnValsMutator]MSP[] } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; MST[NullReturnValsMutator]MSP[] } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[] } @Override public void clear () {
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; return result ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI4Mutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI3Mutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI2Mutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI1Mutator]MSP[] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; MST[ConstructorCallMutator]MSP[] } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.ABSMutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR5Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI1Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR6Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR4Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[ConstructorCallMutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR5Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI3Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR4Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI2Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI4Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[experimental.MemberVariableMutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOD1Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOD2Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR3Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR2Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[ConditionalsBoundaryMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[BooleanTrueReturnValsMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR3Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[] }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[ReturnValsMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOD2Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR2Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI1Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR1Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI3Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; MST[experimental.MemberVariableMutator]MSP[] } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.ABSMutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR3Mutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[NegateConditionalsMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR4Mutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR2Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR2Mutator]MSP[]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR1Mutator]MSP[]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR5Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR6Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[InlineConstantMutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; MST[ArgumentPropagationMutator]MSP[] currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR1Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[NonVoidMethodCallMutator]MSP[]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR1Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI2Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR2Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[experimental.MemberVariableMutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI1Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI2Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[experimental.MemberVariableMutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR2Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR4Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; MST[ReturnValsMutator]MSP[] } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[MathMutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[VoidMethodCallMutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { MST[experimental.MemberVariableMutator]MSP[] return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR5Mutator]MSP[]
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI4Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[InlineConstantMutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR4Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR2Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[NonVoidMethodCallMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR5Mutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ABSMutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR2Mutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR6Mutator]MSP[] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR3Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR4Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR3Mutator]MSP[]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; MST[ConstructorCallMutator]MSP[] } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[InlineConstantMutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR1Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[NegateConditionalsMutator]MSP[]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR4Mutator]MSP[]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[MathMutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOD1Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI3Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR3Mutator]MSP[] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI4Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; MST[NullReturnValsMutator]MSP[] } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR3Mutator]MSP[] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR4Mutator]MSP[] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[ReturnValsMutator]MSP[] } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[NullReturnValsMutator]MSP[] } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
return nextEntry () . getValue () ; MST[NonVoidMethodCallMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeInt ( size () ) ;
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
if ( obj instanceof Map . Entry == false ) { return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ; MST[NonVoidMethodCallMutator]MSP[]
return getKey () + lr_3 + getValue () ; MST[experimental.NakedReceiverMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[experimental.MemberVariableMutator]MSP[] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ; MST[ReturnValsMutator]MSP[]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR3Mutator]MSP[]
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR1Mutator]MSP[]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.ABSMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR5Mutator]MSP[]
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; MST[NullReturnValsMutator]MSP[] } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
switch ( index ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
switch ( index ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
switch ( index ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[ReturnValsMutator]MSP[] }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI3Mutator]MSP[] case 3 : return parent . key3 ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR5Mutator]MSP[] }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR1Mutator]MSP[] }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
switch ( index ) { MST[rv.UOI4Mutator]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR1Mutator]MSP[] return false ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR5Mutator]MSP[] return false ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; MST[ReturnValsMutator]MSP[] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.ABSMutator]MSP[] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI2Mutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[] } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[ReturnValsMutator]MSP[] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; MST[NonVoidMethodCallMutator]MSP[] case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; }
if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.ABSMutator]MSP[] case 3 : return parent . key3 ;
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI2Mutator]MSP[] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI3Mutator]MSP[] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } @Override public V setValue ( final V value ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
return getKey () + lr_3 + getValue () ; MST[experimental.NakedReceiverMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; MST[NullReturnValsMutator]MSP[] case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR4Mutator]MSP[] return 0 ; } final Object key = getKey () ;
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR2Mutator]MSP[] return 0 ; } final Object key = getKey () ;
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR5Mutator]MSP[] return 0 ; } final Object key = getKey () ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
case 2 : return parent . key2 ; MST[NonVoidMethodCallMutator]MSP[] case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { return 0 ; } final Object key = getKey () ; MST[NonVoidMethodCallMutator]MSP[]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NullReturnValsMutator]MSP[] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI1Mutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( removed ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI1Mutator]MSP[] case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; MST[ReturnValsMutator]MSP[] case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR3Mutator]MSP[] }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR6Mutator]MSP[] }
switch ( index ) { case 3 : return parent . value3 ; MST[NullReturnValsMutator]MSP[] case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR2Mutator]MSP[]
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI3Mutator]MSP[] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NonVoidMethodCallMutator]MSP[] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { MST[rv.UOI2Mutator]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI2Mutator]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR3Mutator]MSP[] return false ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.SwitchMutator]MSP[] case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI4Mutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; MST[ArgumentPropagationMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; MST[NonVoidMethodCallMutator]MSP[] break; case 1 :
switch ( index ) { case 3 : return parent . value3 ; MST[ReturnValsMutator]MSP[] case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; MST[NonVoidMethodCallMutator]MSP[] switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
switch ( index ) { MST[experimental.SwitchMutator]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[InlineConstantMutator]MSP[] }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ; MST[NullReturnValsMutator]MSP[]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
switch ( index ) { MST[rv.UOI3Mutator]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
switch ( index ) { MST[rv.UOI1Mutator]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.ABSMutator]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; MST[NonVoidMethodCallMutator]MSP[] case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[NegateConditionalsMutator]MSP[] return 0 ; } final Object key = getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
return getKey () + lr_3 + getValue () ; MST[ReturnValsMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI4Mutator]MSP[] case 3 : return parent . key3 ;
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; MST[NullReturnValsMutator]MSP[] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
case 2 : return parent . key2 ; MST[NullReturnValsMutator]MSP[] case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI1Mutator]MSP[] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR4Mutator]MSP[]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI4Mutator]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ; MST[NonVoidMethodCallMutator]MSP[]
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; MST[ReturnValsMutator]MSP[] } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI4Mutator]MSP[] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[] } @Override public V setValue ( final V value ) {
if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI1Mutator]MSP[] } @Override public V setValue ( final V value ) {
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return 0 ; } final Object key = getKey () ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 3 : return parent . key3 ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 3 : return parent . key3 ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.SwitchMutator]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR3Mutator]MSP[] return 0 ; } final Object key = getKey () ;
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR1Mutator]MSP[] return 0 ; } final Object key = getKey () ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 3 : return parent . key3 ;
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[NegateConditionalsMutator]MSP[]
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI3Mutator]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI2Mutator]MSP[] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
if ( removed ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
return getKey () + lr_3 + getValue () ; MST[ConstructorCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; MST[ArgumentPropagationMutator]MSP[] break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI4Mutator]MSP[] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI1Mutator]MSP[] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V setValue ( final V value ) {
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR4Mutator]MSP[] return false ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR2Mutator]MSP[] return false ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return 0 ; } final Object key = getKey () ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[NegateConditionalsMutator]MSP[] return false ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI3Mutator]MSP[] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.ABSMutator]MSP[] } @Override public V setValue ( final V value ) {
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } @Override public V setValue ( final V value ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; MST[ConstructorCallMutator]MSP[] } switch ( index ) { case 3 : return parent . key3 ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI2Mutator]MSP[] case 3 : return parent . key3 ;
switch ( index ) { MST[rv.ABSMutator]MSP[] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; MST[ReturnValsMutator]MSP[] case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; MST[experimental.NakedReceiverMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
return getKey () + lr_3 + getValue () ; MST[EmptyObjectReturnValsMutator]MSP[] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
parent . value1 = value ; MST[NonVoidMethodCallMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; MST[NonVoidMethodCallMutator]MSP[] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[NonVoidMethodCallMutator]MSP[]
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public void clear () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . <V > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . <V > emptyIterator () ; MST[ReturnValsMutator]MSP[] } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[] } @Override public void clear () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[]
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . <V > emptyIterator () ; MST[NullReturnValsMutator]MSP[] } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[]
