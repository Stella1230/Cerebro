return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[ConstructorCallMutator]MSP[S] } @Override
map . put ( key , coll ) ; return true ; MST[InlineConstantMutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[rv.ABSMutator]MSP[N] } @Override public Collection < V > values () {
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public Collection < V > values () {
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
int size = 0 ; MST[InlineConstantMutator]MSP[N] for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; } @Override public Collection < V > values () {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[NegateConditionalsMutator]MSP[N]
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.UOI3Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[rv.UOI2Mutator]MSP[N] } @Override public Collection < V > values () {
int size = 0 ; MST[rv.CRCR6Mutator]MSP[S] for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; } @Override public Collection < V > values () {
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[rv.ROR5Mutator]MSP[N]
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override
Objects . requireNonNull ( map , lr_2 ) ; MST[ArgumentPropagationMutator]MSP[N] boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[rv.ROR1Mutator]MSP[N]
map . put ( key , coll ) ; return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
map . put ( key , coll ) ; return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.OBBN3Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) {
map . put ( key , coll ) ; MST[ArgumentPropagationMutator]MSP[N] return true ; } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
Objects . requireNonNull ( map , lr_2 ) ; boolean changed = false ; MST[rv.CRCR6Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
getMap () . remove ( key ) ; } return changed ; } @Override public boolean isEmpty () { return getMap () . isEmpty () ; MST[ReturnValsMutator]MSP[N] } @Override public Set < K > keySet () { return getMap () . keySet () ; } @Override public int size () {
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[rv.ROR5Mutator]MSP[S] } @Override
boolean changed = false ; MST[rv.CRCR1Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override
return asMap () . equals ( ( ( MultiValuedMap < ? , ? > ) obj ) . asMap () ) ; } return false ; } @Override public int hashCode () { return getMap () . hashCode () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () {
int size = 0 ; MST[rv.CRCR3Mutator]MSP[S] for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; } @Override public Collection < V > values () {
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[rv.UOI1Mutator]MSP[N] } @Override public Collection < V > values () {
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ; MST[ArgumentPropagationMutator]MSP[N]
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
Objects . requireNonNull ( map , lr_2 ) ; boolean changed = false ; MST[rv.CRCR3Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
Objects . requireNonNull ( map , lr_2 ) ; boolean changed = false ; MST[InlineConstantMutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
boolean changed = false ; MST[rv.CRCR6Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override
boolean changed = false ; MST[InlineConstantMutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] coll = createCollection () ; if ( coll . add ( value ) ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[N] coll = createCollection () ; if ( coll . add ( value ) ) {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[NonVoidMethodCallMutator]MSP[N]
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[rv.UOI3Mutator]MSP[N] } @Override public Collection < V > values () {
int size = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; } @Override public Collection < V > values () {
protected Map < K , ? extends Collection < V > > getMap () { return map ; MST[NullReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 ) protected void setMap ( final Map < K , ? extends Collection < V > > map ) {
Objects . requireNonNull ( map , lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[ReturnValsMutator]MSP[S] } @Override
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override
map . put ( key , coll ) ; return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
map . put ( key , coll ) ; return true ; } return false ; } return coll . add ( value ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.OBBN2Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[rv.ROR4Mutator]MSP[N]
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.ABSMutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { MST[NonVoidMethodCallMutator]MSP[S] changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.UOI4Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
return asMap () . equals ( ( ( MultiValuedMap < ? , ? > ) obj ) . asMap () ) ; } return false ; } @Override public int hashCode () { return getMap () . hashCode () ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () {
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[experimental.MemberVariableMutator]MSP[N] } @Override
protected Map < K , ? extends Collection < V > > getMap () { return map ; MST[ReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 ) protected void setMap ( final Map < K , ? extends Collection < V > > map ) {
Objects . requireNonNull ( map , lr_2 ) ; boolean changed = false ; MST[rv.CRCR5Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; MST[ArgumentPropagationMutator]MSP[N] if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) {
map . put ( key , coll ) ; return true ; } return false ; } return coll . add ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
map . put ( key , coll ) ; return true ; } return false ; } return coll . add ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[MathMutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override
map . put ( key , coll ) ; return true ; MST[ReturnValsMutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
boolean changed = false ; MST[rv.CRCR3Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[rv.UOI4Mutator]MSP[S] } @Override public Collection < V > values () {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.OBBN1Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
return asMap () . equals ( ( ( MultiValuedMap < ? , ? > ) obj ) . asMap () ) ; } return false ; } @Override public int hashCode () { return getMap () . hashCode () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public String toString () {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[rv.ROR3Mutator]MSP[N]
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
map . put ( key , coll ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { MST[NonVoidMethodCallMutator]MSP[S] size += col . size () ; } return size ; } @Override public Collection < V > values () {
map . put ( key , coll ) ; return true ; } return false ; } return coll . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
getMap () . remove ( key ) ; } return changed ; } @Override public boolean isEmpty () { return getMap () . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Set < K > keySet () { return getMap () . keySet () ; } @Override public int size () {
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; MST[ReturnValsMutator]MSP[N] } @Override public Collection < V > values () {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] coll = createCollection () ; if ( coll . add ( value ) ) {
int size = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final Collection < V > col : getMap () . values () ) { size += col . size () ; } return size ; } @Override public Collection < V > values () {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[N] coll = createCollection () ; if ( coll . add ( value ) ) {
getMap () . remove ( key ) ; } return changed ; } @Override public boolean isEmpty () { return getMap () . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Set < K > keySet () { return getMap () . keySet () ; } @Override public int size () {
getMap () . remove ( key ) ; } return changed ; } @Override public boolean isEmpty () { return getMap () . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public Set < K > keySet () { return getMap () . keySet () ; } @Override public int size () {
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[NegateConditionalsMutator]MSP[S] } @Override
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
return asMap () . equals ( ( ( MultiValuedMap < ? , ? > ) obj ) . asMap () ) ; } return false ; } @Override public int hashCode () { return getMap () . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () {
map . put ( key , coll ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
changed |= put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return changed ; } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; if ( coll . add ( value ) ) { MST[rv.ROR2Mutator]MSP[N]
Objects . requireNonNull ( map , lr_2 ) ; boolean changed = false ; MST[rv.CRCR1Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
map . put ( key , coll ) ; return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
map . put ( key , coll ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } return coll . add ( value ) ; } @Override public boolean putAll ( final Map < ? extends K , ? extends V > map ) {
getMap () . remove ( key ) ; } return changed ; } @Override public boolean isEmpty () { return getMap () . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Set < K > keySet () { return getMap () . keySet () ; } @Override public int size () {
public boolean put ( final K key , final V value ) { Collection < V > coll = getMap () . get ( key ) ; if ( coll == null ) { coll = createCollection () ; MST[NonVoidMethodCallMutator]MSP[N] if ( coll . add ( value ) ) {
Objects . requireNonNull ( map , lr_2 ) ; boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[S]
boolean changed = false ; MST[rv.CRCR5Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; } @Override
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean putAll ( final MultiValuedMap < ? extends K , ? extends V > map ) { Objects . requireNonNull ( map , lr_2 ) ;
int size = 0 ; for ( final Collection < V > col : getMap () . values () ) { MST[NonVoidMethodCallMutator]MSP[S] size += col . size () ; } return size ; } @Override public Collection < V > values () {
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override
boolean changed = false ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entries () ) { changed |= put ( entry . getKey () , entry . getValue () ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override
return coll != null && coll . contains ( value ) ; } @Override public Collection < Entry < K , V > > entries () { return entryValuesView != null ? entryValuesView : ( entryValuesView = new EntryValues () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override MST[experimental.MemberVariableMutator]MSP[S] protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override MST[NonVoidMethodCallMutator]MSP[S] protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[NegateConditionalsMutator]MSP[S] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[rv.ROR5Mutator]MSP[S] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[rv.ROR4Mutator]MSP[S] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[rv.ROR2Mutator]MSP[S] return null ; }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { return null ; MST[ReturnValsMutator]MSP[S] }
} @Override public int getCount () { return mapEntry . getValue () . size () ; } @Override protected Iterator < ? extends Entry < K , V > > nextIterator ( final int count ) { if ( ! keyIterator . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; }
return iterator . next () ; MST[NullReturnValsMutator]MSP[N] } @Override public Set < Map . Entry < K , Collection < V > > > entrySet () { return new AsMapEntrySet () ; } @Override public boolean containsKey ( final Object key ) { return decoratedMap . containsKey ( key ) ;
return iterator . next () ; MST[ReturnValsMutator]MSP[N] } @Override public Set < Map . Entry < K , Collection < V > > > entrySet () { return new AsMapEntrySet () ; } @Override public boolean containsKey ( final Object key ) { return decoratedMap . containsKey ( key ) ;
public void remove () { iterator . remove () ; if ( values . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[ReturnValsMutator]MSP[N] } @Override public V next () {
public void remove () { iterator . remove () ; if ( values . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public V next () {
public void remove () { iterator . remove () ; if ( values . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V next () {
public void remove () { iterator . remove () ; if ( values . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public V next () {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override
return coll == null ? 0 : coll . size () ; MST[InlineConstantMutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.ROR5Mutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[InlineConstantMutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; MST[rv.ROR5Mutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; MST[NullReturnValsMutator]MSP[N] } @Override public int size () { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[NegateConditionalsMutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[ReturnValsMutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[rv.CRCR2Mutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.ROR4Mutator]MSP[S] } @Override
return coll == null ? 0 : coll . size () ; MST[NegateConditionalsMutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; MST[rv.CRCR1Mutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
final Collection < V > coll = getMapping () ; MST[NonVoidMethodCallMutator]MSP[N] if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.ROR2Mutator]MSP[N] } @Override
if ( coll . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } return result ; } @Override public Object [] toArray () { final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[S]
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override
return getMap () . toString () ; } protected Collection < V > getMapping () { return getMap () . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean add ( final V value ) { Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; MST[NonVoidMethodCallMutator]MSP[S] return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
return getMap () . toString () ; } protected Collection < V > getMapping () { return getMap () . get ( key ) ; MST[ReturnValsMutator]MSP[S] } @Override public boolean add ( final V value ) { Collection < V > coll = getMapping () ;
final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
if ( coll . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } return result ; } @Override public Object [] toArray () { final Collection < V > coll = getMapping () ; MST[NonVoidMethodCallMutator]MSP[N] if ( coll == null ) {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override
final Collection < V > coll = getMapping () ; MST[NonVoidMethodCallMutator]MSP[N] return coll == null || coll . isEmpty () ; } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[N] return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.ROR5Mutator]MSP[S] } @Override
return coll == null ? 0 : coll . size () ; MST[ReturnValsMutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.ROR3Mutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[NegateConditionalsMutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[ReturnValsMutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
final Collection < V > coll = getMapping () ; if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; MST[ConstructorCallMutator]MSP[N] } @Override public int size () { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
return getMap () . toString () ; } protected Collection < V > getMapping () { return getMap () . get ( key ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public boolean add ( final V value ) { Collection < V > coll = getMapping () ;
final Collection < V > coll = getMapping () ; if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { final Collection < V > coll = getMapping () ;
return CollectionUtils . EMPTY_COLLECTION . toArray () ; MST[ReturnValsMutator]MSP[S] } return coll . toArray () ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] a ) { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[NegateConditionalsMutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[rv.ROR5Mutator]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
return coll == null ? 0 : coll . size () ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
if ( coll . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } return result ; } @Override public Object [] toArray () { final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[S]
final Collection < V > coll = getMapping () ; if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; MST[NullReturnValsMutator]MSP[S] } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
final Collection < V > coll = getMapping () ; if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ; MST[NonVoidMethodCallMutator]MSP[N]
return CollectionUtils . EMPTY_COLLECTION . toArray () ; MST[NullReturnValsMutator]MSP[S] } return coll . toArray () ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] a ) { final Collection < V > coll = getMapping () ;
return getMap () . toString () ; } protected Collection < V > getMapping () { return getMap () . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean add ( final V value ) { Collection < V > coll = getMapping () ;
if ( coll . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } return result ; } @Override public Object [] toArray () { final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.ROR1Mutator]MSP[N] } @Override
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
final Collection < V > coll = getMapping () ; if ( coll == null ) { return IteratorUtils . EMPTY_ITERATOR ; MST[ReturnValsMutator]MSP[S] } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override
return CollectionUtils . EMPTY_COLLECTION . toArray () ; MST[NonVoidMethodCallMutator]MSP[S] } return coll . toArray () ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] a ) { final Collection < V > coll = getMapping () ;
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override
return coll == null ? 0 : coll . size () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; } @Override
if ( coll . isEmpty () ) { AbstractMultiValuedMap . this . remove ( key ) ; } return result ; } @Override public Object [] toArray () { final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return coll == null ? 0 : coll . size () ; } @Override public boolean contains ( final Object obj ) { final Collection < V > coll = getMapping () ; return coll != null && coll . contains ( obj ) ; MST[InlineConstantMutator]MSP[S] } @Override
final Collection < V > coll = getMapping () ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[N] return IteratorUtils . EMPTY_ITERATOR ; } return new ValuesIterator ( key ) ; } @Override public int size () { final Collection < V > coll = getMapping () ;
final Collection < V > coll = getMapping () ; return coll == null || coll . isEmpty () ; MST[rv.CRCR4Mutator]MSP[N] } @Override public boolean remove ( final Object item ) { final Collection < V > coll = getMapping () ; if ( coll == null ) {
return getMap () . toString () ; } protected Collection < V > getMapping () { return getMap () . get ( key ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override public boolean add ( final V value ) { Collection < V > coll = getMapping () ;
