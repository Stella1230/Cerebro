public Iterator < Map . Entry < K , V > > iterator () { return new EntryIterator () ; MST[ReturnValsMutator]MSP[] } @Override public boolean contains ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new EntryIterator () ; MST[NullReturnValsMutator]MSP[] } @Override public boolean contains ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new EntryIterator () ; MST[ConstructorCallMutator]MSP[] } @Override public boolean contains ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; }
buffer . append ( lr_24 ) . append ( predecessor . getKey () ) . append ( lr_15 ) . append ( predecessor . bitIndex ) . append ( lr_20 ) ; } } buffer . append ( lr_25 ) ; return buffer . toString () ; } @Override MST[experimental.MemberVariableMutator]MSP[]
return AbstractPatriciaTrie . this . size () ; } @Override public void clear () { AbstractPatriciaTrie . this . clear () ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[NullReturnValsMutator]MSP[] } @Override public Iterator < K > iterator () {
return AbstractPatriciaTrie . this . size () ; } @Override public void clear () { AbstractPatriciaTrie . this . clear () ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < K > iterator () {
return AbstractPatriciaTrie . this . size () ; } @Override public void clear () { AbstractPatriciaTrie . this . clear () ; } @Override MST[experimental.MemberVariableMutator]MSP[] public Map . Entry < K , V > next () { return nextEntry () ; } @Override public Iterator < K > iterator () {
return AbstractPatriciaTrie . this . size () ; } @Override public void clear () { AbstractPatriciaTrie . this . clear () ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < K > iterator () {
return key == null ; MST[rv.CRCR3Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR6Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[ReturnValsMutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.ROR5Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[InlineConstantMutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR4Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[NegateConditionalsMutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR3Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR1Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR6Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[rv.CRCR2Mutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[InlineConstantMutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
return key == null ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean isInternalNode () { return left != this && right != this ; } public boolean isExternalNode () { return ! isInternalNode () ; } @Override public String toString () { final StringBuilder buffer = new StringBuilder () ;
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR4Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR1Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( isValidUplink ( current . right , current ) ) { MST[rv.ROR5Mutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ROR3Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; MST[rv.UOI1Mutator]MSP[] addEntry ( t , lengthInBits ) ;
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } if ( isValidUplink ( current . left , current ) ) {
@Override MST[experimental.MemberVariableMutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; MST[ArgumentPropagationMutator]MSP[] }
&& isValidUplink ( current . parent . right , current . parent ) ) { return current . parent . right ; MST[ReturnValsMutator]MSP[] } if ( current . parent . right == current . parent ) { return null ; }
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[NonVoidMethodCallMutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( isValidUplink ( current . right , current ) ) { MST[NegateConditionalsMutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.UOI2Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.ABSMutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ABSMutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[NegateConditionalsMutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[rv.ROR1Mutator]MSP[]
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[rv.UOI2Mutator]MSP[]
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[InlineConstantMutator]MSP[] } @Override
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI3Mutator]MSP[] return current ; } path = current ;
if ( previous == null || start != previous . predecessor ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
return current . left ; MST[ReturnValsMutator]MSP[] } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI3Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[rv.ABSMutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR4Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( child . bitIndex <= node . bitIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
&& isValidUplink ( current . parent . right , current . parent ) ) { return current . parent . right ; } if ( current . parent . right == current . parent ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; }
if ( child . bitIndex <= node . bitIndex ) { MST[ConditionalsBoundaryMutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; MST[NullReturnValsMutator]MSP[] }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.UOI2Mutator]MSP[] } @Override
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI2Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.ROR3Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[NegateConditionalsMutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR3Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.ABSMutator]MSP[] } @Override
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( root . isEmpty () ) { incrementSize () ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.ROR2Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI1Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right MST[rv.ROR5Mutator]MSP[]
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR4Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[rv.ROR1Mutator]MSP[]
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.AOD1Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; MST[rv.UOI4Mutator]MSP[] addEntry ( t , lengthInBits ) ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[RemoveConditionalMutator_ORDER_IF]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( child . bitIndex <= node . bitIndex ) { return child ; MST[NullReturnValsMutator]MSP[] } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[NonVoidMethodCallMutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.AOR3Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.CRCR5Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.ABSMutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI1Mutator]MSP[] current . predecessor = entry ; }
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; MST[NonVoidMethodCallMutator]MSP[] } while ( current == current . parent . right ) { if ( current == tree ) {
return null ; } current = current . parent ; } if ( current == tree ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR1Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[NonVoidMethodCallMutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] current . predecessor = entry ; }
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI2Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
incrementSize () ; MST[VoidMethodCallMutator]MSP[] return null ; } else if ( KeyAnalyzer . isNullBitKey ( bitIndex ) ) { if ( root . isEmpty () ) { incrementSize () ; } else { incrementModCount () ; } return root . setKeyValue ( key , value ) ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI1Mutator]MSP[] return current ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR4Mutator]MSP[] return current ; } path = current ;
if ( previous == null || start != previous . predecessor ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR5Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( child . bitIndex <= node . bitIndex ) { MST[NegateConditionalsMutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.ROR5Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[NegateConditionalsMutator]MSP[] current . predecessor = entry ; }
if ( found . isEmpty () ) { incrementSize () ; } else { incrementModCount () ; } return found . setKeyValue ( key , value ) ; } final int bitIndex = bitIndex ( key , found . key ) ; MST[NonVoidMethodCallMutator]MSP[]
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI4Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[rv.ROR4Mutator]MSP[]
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ROR1Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ROR5Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI4Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI1Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { entry . left = entry ; MST[experimental.MemberVariableMutator]MSP[] entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.UOI4Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ABSMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] child = node . right ; }
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; MST[rv.UOI1Mutator]MSP[] if ( compareKeys ( key , found . key ) ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[RemoveConditionalMutator_ORDER_IF]MSP[] || current . bitIndex <= path . bitIndex ) {
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[rv.ROR1Mutator]MSP[] return null ; } return followLeft ( root ) ; }
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[rv.ROR4Mutator]MSP[]
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ; MST[experimental.MemberVariableMutator]MSP[]
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.AOR4Mutator]MSP[] } @Override
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR3Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } if ( isValidUplink ( current . left , current ) ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( previous != current . right ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { path . left = entry ; } else { path . right = entry ; } return entry ; MST[NullReturnValsMutator]MSP[] } path = current ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR5Mutator]MSP[] current . predecessor = entry ; }
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[] final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { if ( root . isEmpty () ) { incrementSize () ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.ROR1Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[ConditionalsBoundaryMutator]MSP[] current . predecessor = entry ; }
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( lengthInBits == 0 ) { if ( root . isEmpty () ) { incrementSize () ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR2Mutator]MSP[] current . predecessor = entry ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ABSMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[rv.ROR1Mutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[rv.ABSMutator]MSP[]
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.AOR1Mutator]MSP[] } @Override
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[rv.ROR4Mutator]MSP[] return null ; } return followLeft ( root ) ; }
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI3Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; MST[ReturnValsMutator]MSP[] } while ( current == current . parent . right ) { if ( current == tree ) {
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right MST[NegateConditionalsMutator]MSP[]
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR2Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.AOD2Mutator]MSP[] } @Override
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ROR3Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; MST[NullReturnValsMutator]MSP[] } return nextEntryImpl ( node . predecessor , node , null ) ; }
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; MST[rv.UOI3Mutator]MSP[] if ( compareKeys ( key , found . key ) ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR1Mutator]MSP[] return current ; } path = current ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ROR2Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
@Override MST[experimental.MemberVariableMutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[NegateConditionalsMutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.CRCR2Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] child = node . right ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ABSMutator]MSP[] return current ; } path = current ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI4Mutator]MSP[] current . predecessor = entry ; }
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; MST[ArgumentPropagationMutator]MSP[] }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; MST[VoidMethodCallMutator]MSP[] } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR5Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI3Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR3Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ABSMutator]MSP[] current . predecessor = entry ; }
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ROR4Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI2Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.ROR4Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( previous != current . right ) {
incrementSize () ; return null ; MST[ReturnValsMutator]MSP[] } else if ( KeyAnalyzer . isNullBitKey ( bitIndex ) ) { if ( root . isEmpty () ) { incrementSize () ; } else { incrementModCount () ; } return root . setKeyValue ( key , value ) ;
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[rv.ROR2Mutator]MSP[]
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[ConditionalsBoundaryMutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; MST[NonVoidMethodCallMutator]MSP[] if ( compareKeys ( key , found . key ) ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI4Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR3Mutator]MSP[] current . predecessor = entry ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ABSMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI2Mutator]MSP[] current . predecessor = entry ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { return current ; MST[ReturnValsMutator]MSP[] } path = current ;
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.CRCR6Mutator]MSP[] } @Override
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { return current ; MST[NullReturnValsMutator]MSP[] } path = current ;
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.AOD2Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[NegateConditionalsMutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[ConditionalsBoundaryMutator]MSP[] return current ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI1Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[ConditionalsBoundaryMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ABSMutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[experimental.MemberVariableMutator]MSP[] } @Override
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[NegateConditionalsMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( current == tree ) {
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; MST[NullReturnValsMutator]MSP[] }
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR5Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[ReturnValsMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
@Override MST[rv.CRCR1Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[rv.ROR5Mutator]MSP[]
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI2Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.ROR2Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[] final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { if ( root . isEmpty () ) { incrementSize () ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI1Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR4Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; }
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
@Override MST[rv.CRCR1Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI2Mutator]MSP[] return current ; } path = current ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[rv.ROR2Mutator]MSP[] return null ; } return followLeft ( root ) ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.UOI3Mutator]MSP[] } @Override
if ( isValidUplink ( current . right , current ) ) { return current . right ; MST[ReturnValsMutator]MSP[] } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.UOI4Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ROR4Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( previous != current . parent . right
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[ConditionalsBoundaryMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] entrySet = new EntrySet () ; } return entrySet ; } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR3Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI3Mutator]MSP[] current . predecessor = entry ; }
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { MST[NegateConditionalsMutator]MSP[] return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; }
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; MST[rv.UOI3Mutator]MSP[] addEntry ( t , lengthInBits ) ;
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; MST[ReturnValsMutator]MSP[] } return nextEntryImpl ( node . predecessor , node , null ) ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.UOI4Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.ROR1Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI4Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( previous != current . parent . right
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { MST[rv.ROR5Mutator]MSP[] return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; }
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] child = node . right ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI3Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; MST[experimental.MemberVariableMutator]MSP[] } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[NegateConditionalsMutator]MSP[] return null ; } return followLeft ( root ) ; }
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.UOI4Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return nextEntryImpl ( current . parent . right , previous , tree ) ; MST[ArgumentPropagationMutator]MSP[] } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; }
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; MST[experimental.MemberVariableMutator]MSP[] }
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[rv.UOI4Mutator]MSP[]
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR3Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[MathMutator]MSP[] } @Override
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; MST[NonVoidMethodCallMutator]MSP[] }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.AOR2Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR1Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR6Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.CRCR3Mutator]MSP[] } @Override
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[rv.ROR2Mutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( previous == null || start != previous . predecessor ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[NegateConditionalsMutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[NegateConditionalsMutator]MSP[]
@Override MST[InlineConstantMutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI4Mutator]MSP[] return current ; } path = current ;
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[rv.ROR5Mutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.UOI1Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[rv.ROR3Mutator]MSP[]
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI2Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ROR3Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ROR2Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[rv.UOI2Mutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI1Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
return null ; } current = current . parent ; } if ( current == tree ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] child = node . right ; }
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR3Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { path . left = entry ; MST[experimental.MemberVariableMutator]MSP[] } else { path . right = entry ; } return entry ; } path = current ;
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; MST[NullReturnValsMutator]MSP[] } while ( current == current . parent . right ) { if ( current == tree ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
@Override MST[InlineConstantMutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[rv.ROR5Mutator]MSP[] return null ; } return followLeft ( root ) ; }
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { entry . left = entry ; entry . right = current ; MST[experimental.MemberVariableMutator]MSP[] } else { entry . left = current ; entry . right = entry ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.ROR5Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.UOI3Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI4Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( isValidUplink ( current . right , current ) ) { MST[rv.ROR2Mutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
&& isValidUplink ( current . parent . right , current . parent ) ) { return current . parent . right ; } if ( current . parent . right == current . parent ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; }
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.ROR4Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( previous != current . parent . right
return nextEntryImpl ( current . parent . right , previous , tree ) ; MST[NonVoidMethodCallMutator]MSP[] } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; }
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ABSMutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR5Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI1Mutator]MSP[] current . predecessor = entry ; }
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[rv.ROR3Mutator]MSP[] return null ; } return followLeft ( root ) ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[InlineConstantMutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ROR4Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[NegateConditionalsMutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] child = node . right ; }
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; MST[ReturnValsMutator]MSP[] }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI3Mutator]MSP[] return current ; } path = current ;
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; MST[rv.UOI2Mutator]MSP[] if ( compareKeys ( key , found . key ) ) {
@Override MST[rv.CRCR5Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } return followLeft ( root ) ; }
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] child = node . right ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.AOD1Mutator]MSP[] } @Override
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[ConditionalsBoundaryMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[NonVoidMethodCallMutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; MST[rv.ABSMutator]MSP[] if ( compareKeys ( key , found . key ) ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.UOI2Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
if ( isValidUplink ( current . right , current ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
&& isValidUplink ( current . parent . right , current . parent ) ) { return current . parent . right ; MST[NullReturnValsMutator]MSP[] } if ( current . parent . right == current . parent ) { return null ; }
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[PrimitiveReturnsMutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI2Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
return null ; } current = current . parent ; } if ( current == tree ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR1Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( entrySet == null ) { entrySet = new EntrySet () ; MST[experimental.MemberVariableMutator]MSP[] } return entrySet ; } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[NonVoidMethodCallMutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return current ; } path = current ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI1Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR4Mutator]MSP[] current . predecessor = entry ; }
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
&& isValidUplink ( current . parent . right , current . parent ) ) { return current . parent . right ; } if ( current . parent . right == current . parent ) { MST[NegateConditionalsMutator]MSP[] return null ; }
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[NegateConditionalsMutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] child = node . right ; }
@Override MST[rv.CRCR5Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[rv.ROR3Mutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
if ( previous == null || start != previous . predecessor ) { MST[NegateConditionalsMutator]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.CRCR5Mutator]MSP[] } @Override
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI2Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR5Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.CRCR4Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) { MST[NegateConditionalsMutator]MSP[]
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI3Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR6Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.ABSMutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return null ; } current = current . parent ; } if ( current == tree ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[NegateConditionalsMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.AOR3Mutator]MSP[] } @Override
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
if ( isValidUplink ( current . right , current ) ) { MST[NonVoidMethodCallMutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR4Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ROR5Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI1Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.ROR3Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[NegateConditionalsMutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI4Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( previous != current . parent . right
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; MST[ConstructorCallMutator]MSP[] addEntry ( t , lengthInBits ) ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR5Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[ArgumentPropagationMutator]MSP[]
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR4Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR2Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
if ( isValidUplink ( current . right , current ) ) { MST[rv.ROR3Mutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
entry . predecessor = entry ; MST[experimental.MemberVariableMutator]MSP[] if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ROR1Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { MST[NegateConditionalsMutator]MSP[] if ( current == tree ) {
return current . left ; MST[NullReturnValsMutator]MSP[] } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[NonVoidMethodCallMutator]MSP[]
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( previous != current . parent . right
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI3Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { MST[rv.ROR5Mutator]MSP[] if ( current == tree ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ABSMutator]MSP[] return current ; } path = current ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[rv.UOI1Mutator]MSP[]
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.UOI1Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.ROR1Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.UOI3Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
if ( entrySet == null ) { entrySet = new EntrySet () ; } return entrySet ; MST[ReturnValsMutator]MSP[] } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ABSMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[NonVoidMethodCallMutator]MSP[]
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR3Mutator]MSP[] return current ; } path = current ;
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ROR1Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } return followLeft ( root ) ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[rv.UOI3Mutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) { MST[NegateConditionalsMutator]MSP[]
return nextEntryImpl ( current . parent . right , previous , tree ) ; MST[ReturnValsMutator]MSP[] } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; }
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[NegateConditionalsMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; MST[rv.UOI2Mutator]MSP[] addEntry ( t , lengthInBits ) ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR2Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ABSMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR1Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; MST[NonVoidMethodCallMutator]MSP[] }
} entry . parent = path ; MST[experimental.MemberVariableMutator]MSP[] if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI4Mutator]MSP[] current . predecessor = entry ; }
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR2Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) { MST[rv.ROR5Mutator]MSP[]
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.UOI3Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.UOI1Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.AOR1Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI4Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.CRCR2Mutator]MSP[] } @Override
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI3Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ROR3Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR2Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[rv.UOI3Mutator]MSP[]
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return nextEntryImpl ( current . parent . right , previous , tree ) ; } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] return null ; } return followLeft ( root ) ; }
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( previous != current . right ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.UOI2Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[ReturnValsMutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( entrySet == null ) { MST[NegateConditionalsMutator]MSP[] entrySet = new EntrySet () ; } return entrySet ; } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR1Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR2Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( isValidUplink ( current . right , current ) ) { MST[rv.ROR1Mutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.ROR3Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( previous != current . right ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { path . left = entry ; } else { path . right = entry ; MST[experimental.MemberVariableMutator]MSP[] } return entry ; } path = current ;
if ( entrySet == null ) { MST[rv.ROR5Mutator]MSP[] entrySet = new EntrySet () ; } return entrySet ; } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.AOR2Mutator]MSP[] } @Override
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[rv.ROR2Mutator]MSP[]
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.UOI1Mutator]MSP[] } @Override
if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] entrySet = new EntrySet () ; } return entrySet ; } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ABSMutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[rv.UOI1Mutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[rv.ROR4Mutator]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI4Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR5Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ; MST[NonVoidMethodCallMutator]MSP[]
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[rv.ROR4Mutator]MSP[] if ( root . isEmpty () ) { incrementSize () ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.UOI2Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.CRCR3Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI3Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI1Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI2Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR5Mutator]MSP[] return current ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI4Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( child . bitIndex <= node . bitIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI1Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI2Mutator]MSP[] current . predecessor = entry ; }
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.CRCR6Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; MST[ReturnValsMutator]MSP[] }
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[NegateConditionalsMutator]MSP[]
return null ; } current = current . parent ; } if ( current == tree ) { return null ; } if ( current . parent . right == null ) { return null ; } if ( previous != current . parent . right MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[NegateConditionalsMutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( isValidUplink ( current . right , current ) ) { return current . right ; MST[NullReturnValsMutator]MSP[] } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; MST[rv.UOI4Mutator]MSP[] } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; MST[rv.ABSMutator]MSP[] addEntry ( t , lengthInBits ) ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI2Mutator]MSP[] return current ; } path = current ;
if ( entrySet == null ) { entrySet = new EntrySet () ; } return entrySet ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return current ; } path = current ;
if ( entrySet == null ) { entrySet = new EntrySet () ; MST[ConstructorCallMutator]MSP[] } return entrySet ; } @Override public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet () ; } return keySet ; } @Override
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR4Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.AOR4Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] current . predecessor = entry ; }
if ( isValidUplink ( current . right , current ) ) { MST[rv.ROR4Mutator]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI3Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { entry . left = entry ; entry . right = current ; } else { entry . left = current ; MST[experimental.MemberVariableMutator]MSP[] entry . right = entry ;
@Override MST[rv.CRCR6Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.UOI2Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[NonVoidMethodCallMutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] child = node . right ; }
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.CRCR5Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.CRCR4Mutator]MSP[] } @Override
if ( child . bitIndex <= node . bitIndex ) { return child ; MST[ReturnValsMutator]MSP[] } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[rv.UOI3Mutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; if ( compareKeys ( key , found . key ) ) { MST[rv.ROR5Mutator]MSP[]
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ROR5Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { return firstEntry () ; MST[NonVoidMethodCallMutator]MSP[] } return nextEntryImpl ( node . predecessor , node , null ) ; }
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI3Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[NegateConditionalsMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
@Override MST[rv.CRCR6Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[NegateConditionalsMutator]MSP[] return current ; } path = current ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR3Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( previous == null || start != previous . predecessor ) { MST[rv.ROR5Mutator]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[InlineConstantMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI1Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR1Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { MST[rv.ROR5Mutator]MSP[] break; } if ( isValidUplink ( current . left , current ) ) {
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( current == tree ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { path . left = entry ; } else { path . right = entry ; } return entry ; MST[ReturnValsMutator]MSP[] } path = current ;
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ROR2Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
return nextEntryImpl ( current . parent . right , previous , tree ) ; MST[NullReturnValsMutator]MSP[] } TrieEntry < K , V > firstEntry () { if ( isEmpty () ) { return null ; } return followLeft ( root ) ; }
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.ROR2Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ROR5Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.ROR2Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( isValidUplink ( current . right , current ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) {
if ( previous == null || start != previous . predecessor ) { MST[NegateConditionalsMutator]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.ABSMutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { MST[NegateConditionalsMutator]MSP[] break; } if ( isValidUplink ( current . left , current ) ) {
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI1Mutator]MSP[] return current ; } path = current ;
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.UOI1Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( ! isBitSet ( key , current . bitIndex , lengthInBits ) ) { MST[rv.UOI1Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } V removeEntry ( final TrieEntry < K , V > h ) {
@Override MST[rv.CRCR3Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI3Mutator]MSP[] current . predecessor = entry ; }
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; MST[rv.UOI4Mutator]MSP[] } @Override
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[NegateConditionalsMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { MST[rv.ROR1Mutator]MSP[] current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { current . predecessor = entry ; }
if ( child . bitIndex <= node . bitIndex ) { MST[rv.UOI4Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
if ( child . bitIndex <= node . bitIndex ) { MST[rv.ROR4Mutator]MSP[] return child ; } node = child ; } } @Override public Comparator < ? super K > comparator () { return getKeyAnalyzer () ; } @Override public K firstKey () {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI3Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
} else { incrementModCount () ; } return root . setKeyValue ( key , value ) ; } final TrieEntry < K , V > found = getNearestEntryForKey ( key , lengthInBits ) ; MST[rv.UOI4Mutator]MSP[] if ( compareKeys ( key , found . key ) ) {
if ( ! isBitSet ( entry . key , current . bitIndex , lengthInBits ) ) { MST[rv.ROR3Mutator]MSP[] current = current . left ; } else { current = current . right ; } } } @Override public V get ( final Object k ) {
if ( previous == null || start != previous . predecessor ) { MST[rv.ROR5Mutator]MSP[] while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[NegateConditionalsMutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; } while ( current == current . parent . right ) { if ( current == tree ) { MST[rv.ROR5Mutator]MSP[]
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[InlineConstantMutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
@Override MST[rv.CRCR3Mutator]MSP[] public void clear () { root . key = null ; root . bitIndex = - 1 ; root . value = null ; root . parent = null ; root . left = root ; root . right = null ; root . predecessor = root ;
public V put ( final K key , final V value ) { Objects . requireNonNull ( key , lr_1 ) ; final int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( root . isEmpty () ) { incrementSize () ;
&& isValidUplink ( current . parent . right , current . parent ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return current . parent . right ; } if ( current . parent . right == current . parent ) { return null ; }
if ( isValidUplink ( current . right , current ) ) { return current . right ; } return nextEntryImpl ( current . right , previous , tree ) ; MST[ArgumentPropagationMutator]MSP[] } while ( current == current . parent . right ) { if ( current == tree ) {
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[MathMutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
size = 0 ; incrementModCount () ; } @Override public int size () { return size ; } void incrementSize () { size ++ ; MST[experimental.MemberVariableMutator]MSP[] incrementModCount () ; } void decrementSize () { size -- ; incrementModCount () ; } private void incrementModCount () { ++ modCount ; } @Override
return next != null && next . bitIndex <= from . bitIndex && ! next . isEmpty () ; MST[rv.UOI4Mutator]MSP[] } public void set ( final E item ) { this . item = item ; } public E get () { return item ; } public boolean isEmpty () {
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[rv.UOI2Mutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
&& isValidUplink ( current . parent . right , current . parent ) ) { return current . parent . right ; } if ( current . parent . right == current . parent ) { MST[rv.ROR5Mutator]MSP[] return null ; }
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.ROR5Mutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { MST[rv.ABSMutator]MSP[] final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
entry . predecessor = entry ; if ( ! isBitSet ( entry . key , entry . bitIndex , lengthInBits ) ) { MST[rv.ROR2Mutator]MSP[] entry . left = entry ; entry . right = current ; } else { entry . left = current ; entry . right = entry ;
if ( ! KeyAnalyzer . isOutOfBoundsIndex ( bitIndex ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( KeyAnalyzer . isValidBitIndex ( bitIndex ) ) { final TrieEntry < K , V > t = new TrieEntry <> ( key , value , bitIndex ) ; addEntry ( t , lengthInBits ) ;
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR2Mutator]MSP[] return current ; } path = current ;
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) {
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ABSMutator]MSP[] current . predecessor = entry ; }
return current . left ; } current = current . left ; } } if ( current . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( current . right == null ) { return null ; } if ( previous != current . right ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex <= path . bitIndex ) { MST[rv.UOI4Mutator]MSP[] return current ; } path = current ;
} TrieEntry < K , V > nextEntry ( final TrieEntry < K , V > node ) { if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return firstEntry () ; } return nextEntryImpl ( node . predecessor , node , null ) ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.UOI2Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( path == root || ! isBitSet ( entry . key , path . bitIndex , lengthInBits ) ) { MST[rv.ROR5Mutator]MSP[] path . left = entry ; } else { path . right = entry ; } return entry ; } path = current ;
} entry . parent = path ; if ( current . bitIndex >= entry . bitIndex ) { current . parent = entry ; } if ( current . bitIndex <= path . bitIndex ) { MST[rv.ROR1Mutator]MSP[] current . predecessor = entry ; }
TrieEntry < K , V > followLeft ( TrieEntry < K , V > node ) { while ( true ) { TrieEntry < K , V > child = node . left ; if ( child . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] child = node . right ; }
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ROR5Mutator]MSP[] || current . bitIndex <= path . bitIndex ) {
TrieEntry < K , V > current = root . left ; TrieEntry < K , V > path = root ; while ( true ) { if ( current . bitIndex >= entry . bitIndex MST[rv.ABSMutator]MSP[] || current . bitIndex <= path . bitIndex ) {
if ( previous == null || start != previous . predecessor ) { while ( ! current . left . isEmpty () ) { if ( previous == current . left ) { break; } if ( isValidUplink ( current . left , current ) ) { MST[rv.ROR3Mutator]MSP[]
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[NegateConditionalsMutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
} next = findNext ( e ) ; current = e ; return e ; MST[NullReturnValsMutator]MSP[] } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; } @Override
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
} next = findNext ( e ) ; current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
public boolean hasNext () { return next != null ; MST[ReturnValsMutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
} next = findNext ( e ) ; MST[ArgumentPropagationMutator]MSP[] current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; } @Override
public boolean hasNext () { return next != null ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR3Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR2Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ROR3Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR3Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR6Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
} next = findNext ( e ) ; current = e ; return e ; MST[ReturnValsMutator]MSP[] } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; } @Override
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR6Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ROR2Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[InlineConstantMutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.ROR5Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
} next = findNext ( e ) ; current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; MST[ReturnValsMutator]MSP[] } @Override
public boolean hasNext () { return next != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
public boolean hasNext () { return next != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[InlineConstantMutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
public boolean hasNext () { return next != null ; MST[NegateConditionalsMutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
} next = findNext ( e ) ; current = e ; MST[experimental.MemberVariableMutator]MSP[] return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; } @Override
} next = findNext ( e ) ; current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; MST[ArgumentPropagationMutator]MSP[] } @Override
} next = findNext ( e ) ; MST[NonVoidMethodCallMutator]MSP[] current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; } @Override
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ROR5Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
} next = findNext ( e ) ; current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; MST[NullReturnValsMutator]MSP[] } @Override
public boolean hasNext () { return next != null ; MST[rv.CRCR1Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ROR4Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR5Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException () ;
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
public boolean hasNext () { return next != null ; MST[rv.CRCR5Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
public boolean hasNext () { return next != null ; MST[rv.CRCR4Mutator]MSP[] } @Override public void remove () { if ( current == null ) { throw new IllegalStateException () ; } if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { throw new ConcurrentModificationException () ; }
protected TrieEntry < K , V > nextEntry () { if ( expectedModCount != AbstractPatriciaTrie . this . modCount ) { MST[rv.ROR1Mutator]MSP[] throw new ConcurrentModificationException () ; } final TrieEntry < K , V > e = next ; if ( e == null ) { throw new NoSuchElementException () ;
} next = findNext ( e ) ; MST[experimental.MemberVariableMutator]MSP[] current = e ; return e ; } protected TrieEntry < K , V > findNext ( final TrieEntry < K , V > prior ) { return AbstractPatriciaTrie . this . nextEntry ( prior ) ; } @Override
