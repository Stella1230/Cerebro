public E lower ( final E e ) { return decorated () . lower ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; } @Override public E ceiling ( final E e ) {
public E lower ( final E e ) { return decorated () . lower ( e ) ; } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; MST[NullReturnValsMutator]MSP[] } @Override public E ceiling ( final E e ) {
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[NonVoidMethodCallMutator]MSP[]
public static < E > TransformedNavigableSet < E > transformingNavigableSet ( final NavigableSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { return new TransformedNavigableSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[] }
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI1Mutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI2Mutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI3Mutator]MSP[]
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; MST[ReturnValsMutator]MSP[] } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; } @Override
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[NonVoidMethodCallMutator]MSP[]
public static < E > TransformedNavigableSet < E > transformingNavigableSet ( final NavigableSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { return new TransformedNavigableSet <> ( set , transformer ) ; MST[ReturnValsMutator]MSP[] }
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[rv.UOI4Mutator]MSP[]
return transformingNavigableSet ( tail , transformer ) ; MST[ReturnValsMutator]MSP[] }
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[rv.UOI2Mutator]MSP[]
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[rv.UOI3Mutator]MSP[]
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[rv.UOI1Mutator]MSP[]
return transformingNavigableSet ( head , transformer ) ; MST[ReturnValsMutator]MSP[] } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ;
if ( set . size () > 0 ) { MST[rv.ROR5Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
public E lower ( final E e ) { return decorated () . lower ( e ) ; } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public E ceiling ( final E e ) {
public static < E > TransformedNavigableSet < E > transformingNavigableSet ( final NavigableSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { return new TransformedNavigableSet <> ( set , transformer ) ; MST[NullReturnValsMutator]MSP[] }
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[experimental.NakedReceiverMutator]MSP[]
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
if ( set . size () > 0 ) { MST[rv.ROR1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[experimental.NakedReceiverMutator]MSP[]
return decorated () . pollLast () ; MST[ReturnValsMutator]MSP[] } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
if ( set . size () > 0 ) { MST[rv.ROR3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; MST[ReturnValsMutator]MSP[] } @Override public E pollLast () {
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[rv.UOI1Mutator]MSP[]
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[rv.UOI3Mutator]MSP[]
return transformingNavigableSet ( sub , transformer ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ;
return decorated () . ceiling ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.ABSMutator]MSP[]
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; MST[NullReturnValsMutator]MSP[] } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI4Mutator]MSP[]
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[NonVoidMethodCallMutator]MSP[]
return decorated () . ceiling ( e ) ; MST[NullReturnValsMutator]MSP[] } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI1Mutator]MSP[]
public E lower ( final E e ) { return decorated () . lower ( e ) ; } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E ceiling ( final E e ) {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI1Mutator]MSP[]
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; MST[NullReturnValsMutator]MSP[] } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI4Mutator]MSP[]
if ( set . size () > 0 ) { MST[NegateConditionalsMutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return decorated () . pollLast () ; MST[NullReturnValsMutator]MSP[] } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E pollLast () {
return transformingNavigableSet ( tail , transformer ) ; MST[NullReturnValsMutator]MSP[] }
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[experimental.NakedReceiverMutator]MSP[]
if ( set . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI4Mutator]MSP[]
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[rv.UOI2Mutator]MSP[]
if ( set . size () > 0 ) { MST[rv.ROR4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return transformingNavigableSet ( head , transformer ) ; MST[NullReturnValsMutator]MSP[] } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ;
if ( set . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.ABSMutator]MSP[]
return decorated () . ceiling ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
public E lower ( final E e ) { return decorated () . lower ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; } @Override public E ceiling ( final E e ) {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; MST[NonVoidMethodCallMutator]MSP[] set . clear () ; for ( final E value : values ) {
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI3Mutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI1Mutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI2Mutator]MSP[]
return decorated () . ceiling ( e ) ; MST[ReturnValsMutator]MSP[] } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
return transformingNavigableSet ( sub , transformer ) ; MST[NullReturnValsMutator]MSP[] } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ;
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI2Mutator]MSP[]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI1Mutator]MSP[]
return decorated () . pollLast () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.ABSMutator]MSP[]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI4Mutator]MSP[]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI3Mutator]MSP[]
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E pollLast () {
public static < E > TransformedNavigableSet < E > transformedNavigableSet ( final NavigableSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { final TransformedNavigableSet < E > decorated = new TransformedNavigableSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[]
return transformingNavigableSet ( sub , transformer ) ; MST[ReturnValsMutator]MSP[] } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ;
public E lower ( final E e ) { return decorated () . lower ( e ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; } @Override public E ceiling ( final E e ) {
return decorated () . ceiling ( e ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; MST[NullReturnValsMutator]MSP[] } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; MST[VoidMethodCallMutator]MSP[] for ( final E value : values ) {
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; MST[NullReturnValsMutator]MSP[] } @Override
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
public E lower ( final E e ) { return decorated () . lower ( e ) ; MST[ReturnValsMutator]MSP[] } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; } @Override public E ceiling ( final E e ) {
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; MST[ReturnValsMutator]MSP[] } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[ArgumentPropagationMutator]MSP[] } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.ABSMutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.ABSMutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[NonVoidMethodCallMutator]MSP[]
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[rv.ABSMutator]MSP[]
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; MST[experimental.NakedReceiverMutator]MSP[] } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
public E lower ( final E e ) { return decorated () . lower ( e ) ; MST[NullReturnValsMutator]MSP[] } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; } @Override public E ceiling ( final E e ) {
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; MST[ReturnValsMutator]MSP[] } @Override
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
return transformingNavigableSet ( head , transformer ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ;
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI3Mutator]MSP[]
if ( set . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
public E lower ( final E e ) { return decorated () . lower ( e ) ; } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E ceiling ( final E e ) {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI2Mutator]MSP[]
return decorated () . pollLast () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI3Mutator]MSP[]
return transformingNavigableSet ( head , transformer ) ; } @Override public NavigableSet < E > tailSet ( final E fromElement , final boolean inclusive ) { final NavigableSet < E > tail = decorated () . tailSet ( fromElement , inclusive ) ; MST[rv.ABSMutator]MSP[]
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; } @Override public E pollFirst () { return decorated () . pollFirst () ; MST[NullReturnValsMutator]MSP[] } @Override public E pollLast () {
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; MST[NullReturnValsMutator]MSP[] } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; } @Override
return decorated () . ceiling ( e ) ; } @Override public E higher ( final E e ) { return decorated () . higher ( e ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public E pollFirst () { return decorated () . pollFirst () ; } @Override public E pollLast () {
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; MST[ReturnValsMutator]MSP[] } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; } @Override
return decorated () . pollLast () ; } @Override public NavigableSet < E > descendingSet () { return transformingNavigableSet ( decorated () . descendingSet () , transformer ) ; } @Override public Iterator < E > descendingIterator () { return decorated () . descendingIterator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
return transformingNavigableSet ( tail , transformer ) ; MST[NonVoidMethodCallMutator]MSP[] }
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[rv.UOI4Mutator]MSP[]
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } return decorated ; } @Override protected NavigableSet < E > decorated () { return ( NavigableSet < E > ) super . decorated () ; } @Override
if ( set . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
public E lower ( final E e ) { return decorated () . lower ( e ) ; } @Override public E floor ( final E e ) { return decorated () . floor ( e ) ; MST[ReturnValsMutator]MSP[] } @Override public E ceiling ( final E e ) {
if ( set . size () > 0 ) { MST[rv.ROR2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return transformingNavigableSet ( sub , transformer ) ; } @Override public NavigableSet < E > headSet ( final E toElement , final boolean inclusive ) { final NavigableSet < E > head = decorated () . headSet ( toElement , inclusive ) ; MST[rv.UOI4Mutator]MSP[]
public NavigableSet < E > subSet ( final E fromElement , final boolean fromInclusive , final E toElement , final boolean toInclusive ) { final NavigableSet < E > sub = decorated () . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; MST[NonVoidMethodCallMutator]MSP[]
