final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; MST[VoidMethodCallMutator]MSP[] decorated . decorated () . putAll ( transformed ) ; } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[]
return ( Map < K , V > ) map ; MST[ReturnValsMutator]MSP[] } final Map < K , V > result = new LinkedMap <> ( map . size () ) ;
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[ConstructorCallMutator]MSP[] if ( map . size () > 0 ) {
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[ReturnValsMutator]MSP[] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[NegateConditionalsMutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
decorated () . putAll ( mapToCopy ) ; MST[VoidMethodCallMutator]MSP[] }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[ArgumentPropagationMutator]MSP[] } return result ; } @Override
decorated () . putAll ( mapToCopy ) ; MST[NonVoidMethodCallMutator]MSP[] }
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
return valueTransformer . transform ( object ) ; MST[NullReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR2Mutator]MSP[]
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[NullReturnValsMutator]MSP[] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR1Mutator]MSP[]
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR3Mutator]MSP[]
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR4Mutator]MSP[]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[]
out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[] map = ( Map < K , V > ) in . readObject () ;
return ( Map < K , V > ) map ; } final Map < K , V > result = new LinkedMap <> ( map . size () ) ; MST[ConstructorCallMutator]MSP[]
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[ArgumentPropagationMutator]MSP[] } return result ; } @Override
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR2Mutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; } return result ; } @Override
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; } return result ; MST[NullReturnValsMutator]MSP[] } @Override
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR4Mutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
value = transformValue ( value ) ; MST[ArgumentPropagationMutator]MSP[] return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[NullReturnValsMutator]MSP[] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ; } @Override
return ( Map < K , V > ) map ; MST[NullReturnValsMutator]MSP[] } final Map < K , V > result = new LinkedMap <> ( map . size () ) ;
out . defaultWriteObject () ; out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.ROR5Mutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
return valueTransformer . transform ( object ) ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR1Mutator]MSP[]
value = transformValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[] return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR5Mutator]MSP[]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[InlineConstantMutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR3Mutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
return valueTransformer . transform ( object ) ; MST[ArgumentPropagationMutator]MSP[] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[]
final Transformer < ? super V , ? extends V > valueTransformer ) { return new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[NullReturnValsMutator]MSP[] }
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; MST[ReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[rv.ROR5Mutator]MSP[] return object ; }
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ; } @Override
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[NullReturnValsMutator]MSP[] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ; } @Override
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; MST[NonVoidMethodCallMutator]MSP[] } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; MST[NullReturnValsMutator]MSP[] } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; MST[VoidMethodCallMutator]MSP[] } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return object ; }
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[NegateConditionalsMutator]MSP[]
final Map < K , V > transformed = decorated . transformMap ( map ) ; MST[NonVoidMethodCallMutator]MSP[] decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR2Mutator]MSP[]
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR4Mutator]MSP[]
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[NonVoidMethodCallMutator]MSP[] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
final Transformer < ? super V , ? extends V > valueTransformer ) { return new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[ConstructorCallMutator]MSP[] }
return ( Map < K , V > ) map ; } final Map < K , V > result = new LinkedMap <> ( map . size () ) ; MST[NonVoidMethodCallMutator]MSP[]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[NegateConditionalsMutator]MSP[]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
final Transformer < ? super V , ? extends V > valueTransformer ) { return new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[ReturnValsMutator]MSP[] }
final Map < K , V > transformed = decorated . transformMap ( map ) ; MST[ArgumentPropagationMutator]MSP[] decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[NegateConditionalsMutator]MSP[] return object ; }
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[ReturnValsMutator]MSP[] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; MST[NullReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; MST[ReturnValsMutator]MSP[] } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ; } @Override
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ; MST[ArgumentPropagationMutator]MSP[]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR5Mutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR6Mutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[ArgumentPropagationMutator]MSP[] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ; } @Override
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[NegateConditionalsMutator]MSP[] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
return valueTransformer . transform ( object ) ; MST[ReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ; MST[NonVoidMethodCallMutator]MSP[]
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ; MST[ArgumentPropagationMutator]MSP[]
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[ArgumentPropagationMutator]MSP[] } return result ; } @Override
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; MST[ReturnValsMutator]MSP[] }
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[ReturnValsMutator]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR5Mutator]MSP[]
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[ReturnValsMutator]MSP[] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[ArgumentPropagationMutator]MSP[] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; MST[NullReturnValsMutator]MSP[] }
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[] out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ;
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR3Mutator]MSP[]
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[rv.ROR5Mutator]MSP[] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; } return result ; MST[ReturnValsMutator]MSP[] } @Override
